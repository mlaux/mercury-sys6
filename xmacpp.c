#include <MacTCP.h>#include <Limits.h>#include <MacTypes.h>#include <Resources.h>#include <QuickDraw.h>#include <Fonts.h>#include <Events.h>#include <Windows.h>#include <TextEdit.h>#include <Dialogs.h>#include <Menus.h>#include <Devices.h>#include <ToolUtils.h>#include <MacMemory.h>#include <Files.h>#include <OSUtils.h>#include <DiskInit.h>#include <Traps.h>#include <Sound.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include "tcp.h"#define MBAR_MENU 128#define MENU_APPLE 128#define MENU_CONNECTION 129#define MENU_CHANNEL 130#define MENU_APPLE_ABOUT 1#define MENU_CONNECTION_QUIT 1#define DLOG_SERV_INFO 128#define ALRT_WARNING 128#define IRC_LINE_MAX 512// No longer defined in the libraryQDGlobals qd;StreamPtr gStream;WindowPtr gMainWindow;void toolbox_init(void){	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void menu_init(void){	Handle mbar;		mbar = GetNewMBar(MBAR_MENU);	SetMenuBar(mbar);	DrawMenuBar();}void window_init(void){	Rect wind_bounds;	wind_bounds.top = 80;	wind_bounds.left = 80;	wind_bounds.bottom = 680;	wind_bounds.right = 580;		gMainWindow = NewWindow(NULL, &wind_bounds, "\pXMacPP", true, documentProc, (WindowPtr) -1, false, 0);	SetPort(gMainWindow);	MoveTo(20, 20);	TextSize(9);}void cleanup_and_exit(void){	if(gStream) {		tcp_release_stream(gStream);	}	tcp_cleanup();	dns_cleanup();	ExitToShell();}void log(const char *fmt, ...){	static short y = 20;		va_list list;    Str255 message;        va_start(list, fmt);    message[0] = vsprintf((char *) &message[1], fmt, list);    va_end(list);		DrawString(message);	y += 10;	MoveTo(20, y);}StreamPtr connect(const char *host, const unsigned short port){	StreamPtr stream;	ip_addr ip;	OSErr err;		ip = dns_lookup(host);	if(ip == 0) {		log("ip lookup failed");		return 0;	}	log("host ip %s", dns_format_ip(ip));	stream = tcp_create_stream();	if(stream == 0) {		log("stream failed");		return 0;	}	err = tcp_connect(stream, ip, port);	if(err != noErr) {		log("connect failed %d", err);	}	return stream;}void process_line(const char *line){	char buf[128];	strncpy(buf, line, 128);	buf[127] = 0;	log(buf);}/* THIS ASSUMES \R\N WHICH RFC 1459 REQUIRES BUT IDK IF ALL SERVERS COMPLY *//* Reads as many lines as possible from the network and calls process_line on each *//* Any unfinished lines are left in 'buf' for the next poll operation */void netpoll(StreamPtr stream){	static char buf[IRC_LINE_MAX];	static unsigned short written;	unsigned short read;	char *start, *cr;	OSErr err;		// First, read as much as possible into the buffer	while(written < IRC_LINE_MAX && tcp_available(stream) != 0) {		read = IRC_LINE_MAX - written;		err = tcp_read(stream, buf + written, &read);		if(err != noErr) {			log("read error %d", err);			return;		}		written += read;	}		// Now, look for \r\n, replace with \0, and process each line	start = buf;	while((cr = strchr(start, '\r')) != NULL) {		*cr = '\0';		process_line(start);		written -= cr - start + 2;		start = cr + 2; // skip \n	}		// Finally, move any remaining characters to the beginning of the buffer	// for the next read operation	strncpy(buf, start, written);}void handle_mouse_down(EventRecord *event, WindowPtr window, WindowPartCode clicked_part){	if(clicked_part == inMenuBar) {		long action;		short menu;		short item;				action = MenuSelect(event->where);		if(action > 0) {			menu = HiWord(action);			item = LoWord(action);			switch(menu) {				case MENU_APPLE:					if(item == MENU_APPLE_ABOUT) {						SysBeep(1);					}					break;									case MENU_CONNECTION:					if(item == MENU_CONNECTION_QUIT) {						cleanup_and_exit();					}					break;									case MENU_CHANNEL:					break;			}			HiliteMenu(0);		}	}}int main(void){	EventRecord event;	const char *str;		str = "NICK test123___\r\nUSER test * * :test client\r\n";		toolbox_init();	menu_init();	tcp_init();	dns_init(NULL);		window_init();		gStream = connect("irc.rizon.io", 6667);	tcp_write(gStream, str, strlen(str));		while(1) {		WindowPtr clicked_window;		WindowPartCode clicked_part;				Boolean got_event;		got_event = WaitNextEvent(everyEvent, &event, LONG_MAX, NULL);		if(got_event) {			switch(event.what) {				case mouseDown:					clicked_part = FindWindow(event.where, &clicked_window);					handle_mouse_down(&event, clicked_window, clicked_part);					break;				case updateEvt:					BeginUpdate((WindowPtr) event.message);					EndUpdate((WindowPtr) event.message);					break;				case nullEvent:					netpoll(gStream);					break;							}		} else {			netpoll(gStream);		}	}		return 0;}