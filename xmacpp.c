#include <MacTCP.h>#include <Limits.h>#include <MacTypes.h>#include <Resources.h>#include <QuickDraw.h>#include <Fonts.h>#include <Events.h>#include <Windows.h>#include <TextEdit.h>#include <Dialogs.h>#include <Menus.h>#include <Devices.h>#include <ToolUtils.h>#include <MacMemory.h>#include <Files.h>#include <OSUtils.h>#include <DiskInit.h>#include <Traps.h>#include <Controls.h>#include <ControlDefinitions.h>#include <Sound.h>#include <stdio.h>#include <stdlib.h>#include "irc.h"#include "netutil.h"#include "tcp.h"#define MBAR_MENU 128#define MENU_APPLE 128#define MENU_CONNECTION 129#define MENU_CHANNEL 130#define MENU_APPLE_ABOUT 1#define MENU_CONNECTION_QUIT 1#define DLOG_CONN_INFO 128#define DLOG_CONN_INFO_CONNECT 1#define DLOG_CONN_INFO_QUIT 2#define DLOG_CONN_INFO_HOST 6#define DLOG_CONN_INFO_PORT 7#define DLOG_CONN_INFO_NICK 8#define ALRT_WARNING 128#define HOST_MAX 64#define NICK_MAX 32#define CHAN_MAX 32typedef struct ConnectionInfo {	char host[HOST_MAX];	tcp_port port;	char nick[NICK_MAX];} ConnectionInfo;typedef struct Command {	const char *command;	void (*process)(char **args);} Command;typedef struct Tab {	TEHandle textEdit;	ControlHandle scrollBar;	char name[CHAN_MAX];} Tab;// No longer defined in the libraryQDGlobals qd;StreamPtr gStream;WindowPtr gMainWindow;Tab gServerTab;Tab *gCurrentTab;void strncpy_s(char *dest, const char *src, int n){	strncpy(dest, src, n);	dest[n - 1] = 0;}void toolbox_init(void){	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void menu_init(void){	Handle mbar;		mbar = GetNewMBar(MBAR_MENU);	SetMenuBar(mbar);	DrawMenuBar();}void window_init(void){	Rect wind_bounds;	wind_bounds.top = 80;	wind_bounds.left = 80;	wind_bounds.bottom = 680;	wind_bounds.right = 580;		gMainWindow = NewWindow(NULL, &wind_bounds, "\pXMacPP", true, documentProc, (WindowPtr) -1, true, 0);	SetPort(gMainWindow);}void cleanup_and_exit(void){	if(gStream) {		tcp_release_stream(gStream);	}	if(gMainWindow) {		DisposeWindow(gMainWindow);	}	tcp_cleanup();	dns_cleanup();	ExitToShell();}void te_addline(const char *line, TEHandle te){	static const char newline = '\r';	int len = strlen(line);	TEInsert((char *) line, len, te);	TEInsert(&newline, 1, te);	TESelView(te);}void log(const char *fmt, ...){	va_list list;    char message[256];        va_start(list, fmt);    vsprintf(message, fmt, list);    va_end(list);		te_addline(message, gCurrentTab->textEdit);}StreamPtr connect(const char *host, const unsigned short port){	StreamPtr stream;	ip_addr ip;	OSErr err;		ip = dns_lookup(host);	if(ip == 0) {		log("ip lookup failed");		return 0;	}	log("host ip %s", dns_format_ip(ip));	stream = tcp_create_stream();	if(stream == 0) {		log("stream failed");		return 0;	}	err = tcp_connect(stream, ip, port);	if(err != noErr) {		log("connect failed %d", err);	}	return stream;}void process_line(const char *line){	static int joined;		if(!joined && strstr(line, "Welcome") != 0) {		joined = 1;		//send_join(gStream, "#test");	}		te_addline(line, gCurrentTab->textEdit);}void handle_te_click(Point pt){	GlobalToLocal(&pt);	if(PtInRect(pt, &(**gCurrentTab->textEdit).viewRect)) {		TEClick(pt, false, gCurrentTab->textEdit);	}}void handle_control_click(WindowPtr window, Point where){	ControlPartCode code;	ControlHandle control;	GlobalToLocal(&where);		code = FindControl(where, window, &control);	if(code != 0) {		TrackControl(control, where, 0);	}}void handle_mouse_down(EventRecord *event, WindowPtr window, WindowPartCode clicked_part){	if(clicked_part == inMenuBar) {		long action;		short menu;		short item;				action = MenuSelect(event->where);		if(action > 0) {			menu = HiWord(action);			item = LoWord(action);			switch(menu) {				case MENU_APPLE:					if(item == MENU_APPLE_ABOUT) {						SysBeep(1);					}					break;									case MENU_CONNECTION:					if(item == MENU_CONNECTION_QUIT) {						cleanup_and_exit();					}					break;									case MENU_CHANNEL:					break;			}			HiliteMenu(0);		}	} else if (clicked_part == inDrag) {		DragWindow(window, event->where, &qd.screenBits.bounds);	} else if (clicked_part == inGoAway) {		if(TrackGoAway(window, event->where)) {			DisposeWindow(window);		}	} else if (clicked_part == inContent) {		if (window != FrontWindow()) {			SelectWindow(window);		} else {			handle_te_click(event->where);			handle_control_click(window, event->where);		}	}}void ask_for_deets(ConnectionInfo *ci){	DialogPtr dlg;	DialogItemIndex hit;	DialogItemType type;	Handle host_edit;	Handle port_edit;	Handle nick_edit;	Rect box;		dlg = GetNewDialog(DLOG_CONN_INFO, NULL, (WindowPtr) -1);		GetDialogItem(dlg, DLOG_CONN_INFO_HOST, &type, &host_edit, &box);	GetDialogItem(dlg, DLOG_CONN_INFO_PORT, &type, &port_edit, &box);	GetDialogItem(dlg, DLOG_CONN_INFO_NICK, &type, &nick_edit, &box);	ShowWindow(dlg);	ModalDialog(NULL, &hit);	if(hit == DLOG_CONN_INFO_CONNECT) {		Str255 host, port, nick;		char *c_host, *c_port, *c_nick;				GetDialogItemText(host_edit, host);		GetDialogItemText(port_edit, port);		GetDialogItemText(nick_edit, nick);				c_host = P2CStr(host);		c_port = P2CStr(port);		c_nick = P2CStr(nick);				strncpy_s(ci->host, c_host, HOST_MAX);		strncpy_s(ci->nick, c_nick, NICK_MAX);				ci->port = atoi(c_port);				DisposeDialog(dlg);	} else {		cleanup_and_exit();	}}int get_window_width(WindowPtr wp){	return wp->portRect.right - wp->portRect.left;}int get_window_height(WindowPtr wp){	return wp->portRect.bottom - wp->portRect.top;}#define FONT "\pMonaco"#define TABS_WIDTH 100#define INPUT_HEIGHT 20#define SCROLL_WIDTH 16/* TODO: Make sure TEStyleNew and TESetStyle are supported on System 6 */void tab_new(Tab *tab, const char *name){	short fontNum;	TextStyle style;	Rect rect = gMainWindow->portRect;		rect.left += TABS_WIDTH;	rect.right -= SCROLL_WIDTH;	rect.bottom -= INPUT_HEIGHT;		strncpy_s(tab->name, name, CHAN_MAX);	tab->textEdit = TEStyleNew(&rect, &rect);	TEAutoView(true, tab->textEdit);	GetFNum(FONT, &fontNum);	style.tsFont = fontNum;	TESetStyle(doFont, &style, true, tab->textEdit);	TEActivate(tab->textEdit);		rect = gMainWindow->portRect;	rect.left = rect.right - SCROLL_WIDTH;		tab->scrollBar = NewControl(gMainWindow, &rect, "\p", true, 50, 0, 100, scrollBarProc, 0);}void tab_make_current(Tab *tab){	if(gCurrentTab) {		TEDeactivate(gCurrentTab->textEdit);	}	gCurrentTab = tab;	TEActivate(gCurrentTab->textEdit);}int main(void){	EventRecord event;	ConnectionInfo connection;		toolbox_init();	menu_init();	tcp_init();	dns_init(NULL);		ask_for_deets(&connection);	window_init();		tab_new(&gServerTab, connection.host);	tab_make_current(&gServerTab);		gStream = connect(connection.host, connection.port);	send_userinfo(gStream, connection.nick, "hello", "test client");		while(1) {		WindowPtr clicked_window;		WindowPartCode clicked_part;				Boolean got_event;		got_event = WaitNextEvent(everyEvent, &event, LONG_MAX, NULL);		if(got_event) {			switch(event.what) {				case mouseDown:					clicked_part = FindWindow(event.where, &clicked_window);					handle_mouse_down(&event, clicked_window, clicked_part);					break;				case updateEvt:					BeginUpdate((WindowPtr) event.message);					if(clicked_window == gMainWindow) {						EraseRect(&(**gCurrentTab->textEdit).viewRect);						FrameRect(&(**gCurrentTab->textEdit).viewRect);						TEUpdate(&gMainWindow->portRect, gCurrentTab->textEdit);						DrawControls(gMainWindow);					}					EndUpdate((WindowPtr) event.message);					break;				case nullEvent:					spoll(gStream, process_line);					break;							}		} else {			spoll(gStream, process_line);		}	}		return 0;}