#include <MacTCP.h>#include <Limits.h>#include <MacTypes.h>#include <Resources.h>#include <QuickDraw.h>#include <Fonts.h>#include <Events.h>#include <Windows.h>#include <TextEdit.h>#include <Dialogs.h>#include <Menus.h>#include <Devices.h>#include <ToolUtils.h>#include <MacMemory.h>#include <Files.h>#include <OSUtils.h>#include <DiskInit.h>#include <Traps.h>#include <Sound.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include "tcp.h"#define MBAR_MENU 128#define MENU_APPLE 128#define MENU_CONNECTION 129#define MENU_CHANNEL 130#define MENU_APPLE_ABOUT 1#define MENU_CONNECTION_QUIT 1#define DLOG_CONN_INFO 128#define DLOG_CONN_INFO_CONNECT 1#define DLOG_CONN_INFO_QUIT 2#define DLOG_CONN_INFO_HOST 6#define DLOG_CONN_INFO_PORT 7#define DLOG_CONN_INFO_NICK 8#define ALRT_WARNING 128#define IRC_LINE_MAX 512#define HOST_MAX 64#define NICK_MAX 32// No longer defined in the libraryQDGlobals qd;StreamPtr gStream;WindowPtr gMainWindow;typedef struct ConnectionInfo {	char *host;	char *nick;	unsigned char host_len;	unsigned char nick_len;	tcp_port port;} ConnectionInfo;void toolbox_init(void){	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void menu_init(void){	Handle mbar;		mbar = GetNewMBar(MBAR_MENU);	SetMenuBar(mbar);	DrawMenuBar();}void window_init(void){	Rect wind_bounds;	wind_bounds.top = 80;	wind_bounds.left = 80;	wind_bounds.bottom = 680;	wind_bounds.right = 580;		gMainWindow = NewWindow(NULL, &wind_bounds, "\pXMacPP", true, documentProc, (WindowPtr) -1, false, 0);	SetPort(gMainWindow);	MoveTo(20, 20);	TextSize(9);}void cleanup_and_exit(void){	if(gStream) {		tcp_release_stream(gStream);	}	tcp_cleanup();	dns_cleanup();	ExitToShell();}void log(const char *fmt, ...){	static short y = 20;		va_list list;    Str255 message;        va_start(list, fmt);    message[0] = vsprintf((char *) &message[1], fmt, list);    va_end(list);		DrawString(message);	y += 10;	MoveTo(20, y);}StreamPtr connect(const char *host, const unsigned short port){	StreamPtr stream;	ip_addr ip;	OSErr err;		ip = dns_lookup(host);	if(ip == 0) {		log("ip lookup failed");		return 0;	}	log("host ip %s", dns_format_ip(ip));	stream = tcp_create_stream();	if(stream == 0) {		log("stream failed");		return 0;	}	err = tcp_connect(stream, ip, port);	if(err != noErr) {		log("connect failed %d", err);	}	return stream;}void process_line(const char *line){	char buf[128];	strncpy(buf, line, 128);	buf[127] = 0;	log(buf);}/* THIS ASSUMES \R\N WHICH RFC 1459 REQUIRES BUT IDK IF ALL SERVERS COMPLY *//* Reads as many lines as possible from the network and calls process_line on each *//* Any unfinished lines are left in 'buf' for the next poll operation */void netpoll(StreamPtr stream){	static char buf[IRC_LINE_MAX];	static unsigned short written;	unsigned short read;	char *start, *cr;	OSErr err;		// First, read as much as possible into the buffer	while(written < IRC_LINE_MAX && tcp_available(stream) != 0) {		read = IRC_LINE_MAX - written;		err = tcp_read(stream, buf + written, &read);		if(err != noErr) {			log("read error %d", err);			return;		}		written += read;	}		// Now, look for \r\n, replace with \0, and process each line	start = buf;	while((cr = strchr(start, '\r')) != NULL) {		*cr = '\0';		process_line(start);		written -= cr - start + 2;		start = cr + 2; // skip \n	}		// Finally, move any remaining characters to the beginning of the buffer	// for the next read operation	strncpy(buf, start, written);}void handle_mouse_down(EventRecord *event, WindowPtr window, WindowPartCode clicked_part){	if(clicked_part == inMenuBar) {		long action;		short menu;		short item;				action = MenuSelect(event->where);		if(action > 0) {			menu = HiWord(action);			item = LoWord(action);			switch(menu) {				case MENU_APPLE:					if(item == MENU_APPLE_ABOUT) {						SysBeep(1);					}					break;									case MENU_CONNECTION:					if(item == MENU_CONNECTION_QUIT) {						cleanup_and_exit();					}					break;									case MENU_CHANNEL:					break;			}			HiliteMenu(0);		}	}}void ask_for_deets(ConnectionInfo *ci){	DialogPtr dlg;	DialogItemIndex hit;	DialogItemType type;	Handle host_edit;	Handle port_edit;	Handle nick_edit;	Rect box;		dlg = GetNewDialog(DLOG_CONN_INFO, NULL, (WindowPtr) -1);		GetDialogItem(dlg, DLOG_CONN_INFO_HOST, &type, &host_edit, &box);	GetDialogItem(dlg, DLOG_CONN_INFO_PORT, &type, &port_edit, &box);	GetDialogItem(dlg, DLOG_CONN_INFO_NICK, &type, &nick_edit, &box);	ShowWindow(dlg);	ModalDialog(NULL, &hit);	if(hit == DLOG_CONN_INFO_CONNECT) {		Str255 host, port, nick;		char *c_host, *c_port, *c_nick;				GetDialogItemText(host_edit, host);		GetDialogItemText(port_edit, port);		GetDialogItemText(nick_edit, nick);				c_host = P2CStr(host);		c_port = P2CStr(port);		c_nick = P2CStr(nick);				strncpy(ci->host, c_host, ci->host_len);		ci->host[ci->host_len - 1] = '\0';		strncpy(ci->nick, c_nick, ci->nick_len);		ci->nick[ci->nick_len - 1] = '\0';				ci->port = atoi(c_port);				DisposeDialog(dlg);	} else {		cleanup_and_exit();	}}int main(void){	EventRecord event;	ConnectionInfo connection;	char host[HOST_MAX];	char nick[NICK_MAX];	const char *str;		str = "NICK test123___\r\nUSER test * * :test client\r\n";		toolbox_init();	menu_init();	tcp_init();	dns_init(NULL);		connection.host = host;	connection.host_len = HOST_MAX;	connection.nick = nick;	connection.nick_len = NICK_MAX;		ask_for_deets(&connection);		window_init();		gStream = connect(connection.host, connection.port);	tcp_write(gStream, str, strlen(str));		log("server: %s", connection.host);	log("port: %d", connection.port);	log("nick: %s", connection.nick);		while(1) {		WindowPtr clicked_window;		WindowPartCode clicked_part;				Boolean got_event;		got_event = WaitNextEvent(everyEvent, &event, LONG_MAX, NULL);		if(got_event) {			switch(event.what) {				case mouseDown:					clicked_part = FindWindow(event.where, &clicked_window);					handle_mouse_down(&event, clicked_window, clicked_part);					break;				case updateEvt:					BeginUpdate((WindowPtr) event.message);					EndUpdate((WindowPtr) event.message);					break;				case nullEvent:					netpoll(gStream);					break;							}		} else {			netpoll(gStream);		}	}		return 0;}