#include <MacTCP.h>#include <Limits.h>#include <MacTypes.h>#include <Resources.h>#include <QuickDraw.h>#include <Fonts.h>#include <Events.h>#include <Windows.h>#include <TextEdit.h>#include <Dialogs.h>#include <Menus.h>#include <Devices.h>#include <ToolUtils.h>#include <MacMemory.h>#include <Files.h>#include <OSUtils.h>#include <DiskInit.h>#include <Traps.h>#include <Sound.h>#include <stdio.h>#include <stdlib.h>#include "irc.h"#include "netutil.h"#include "tcp.h"#define MBAR_MENU 128#define MENU_APPLE 128#define MENU_CONNECTION 129#define MENU_CHANNEL 130#define MENU_APPLE_ABOUT 1#define MENU_CONNECTION_QUIT 1#define DLOG_CONN_INFO 128#define DLOG_CONN_INFO_CONNECT 1#define DLOG_CONN_INFO_QUIT 2#define DLOG_CONN_INFO_HOST 6#define DLOG_CONN_INFO_PORT 7#define DLOG_CONN_INFO_NICK 8#define ALRT_WARNING 128#define HOST_MAX 64#define NICK_MAX 32// No longer defined in the libraryQDGlobals qd;StreamPtr gStream;WindowPtr gMainWindow;typedef struct ConnectionInfo {	char host[HOST_MAX];	tcp_port port;	char nick[NICK_MAX];} ConnectionInfo;typedef struct Command {	const char *command;	void (*process)(char **args);} Command;void toolbox_init(void){	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void menu_init(void){	Handle mbar;		mbar = GetNewMBar(MBAR_MENU);	SetMenuBar(mbar);	DrawMenuBar();}void window_init(void){	Rect wind_bounds;	wind_bounds.top = 80;	wind_bounds.left = 80;	wind_bounds.bottom = 680;	wind_bounds.right = 580;		gMainWindow = NewWindow(NULL, &wind_bounds, "\pXMacPP", true, documentProc, (WindowPtr) -1, true, 0);	SetPort(gMainWindow);	MoveTo(20, 20);	TextSize(9);}void cleanup_and_exit(void){	if(gStream) {		tcp_release_stream(gStream);	}	if(gMainWindow) {		DisposeWindow(gMainWindow);	}	tcp_cleanup();	dns_cleanup();	ExitToShell();}void log(const char *fmt, ...){	static short y = 20;		va_list list;    Str255 message;        va_start(list, fmt);    message[0] = vsprintf((char *) &message[1], fmt, list);    va_end(list);		DrawString(message);	y += 10;	if(y > 600) {		Rect rct;		rct.top = 0;		rct.left = 0;		rct.bottom = 600;		rct.right = 500;		EraseRect(&rct);		y = 20;	}	MoveTo(20, y);}StreamPtr connect(const char *host, const unsigned short port){	StreamPtr stream;	ip_addr ip;	OSErr err;		ip = dns_lookup(host);	if(ip == 0) {		log("ip lookup failed");		return 0;	}	log("host ip %s", dns_format_ip(ip));	stream = tcp_create_stream();	if(stream == 0) {		log("stream failed");		return 0;	}	err = tcp_connect(stream, ip, port);	if(err != noErr) {		log("connect failed %d", err);	}	return stream;}void process_line(const char *line){	char buf[128];	static int joined;	strncpy(buf, line, 128);	buf[127] = 0;	if(!joined && strstr(line, "Welcome") != 0) {		joined = 1;		send_join(gStream, "#test");	}	log(buf);}void handle_mouse_down(EventRecord *event, WindowPtr window, WindowPartCode clicked_part){	if(clicked_part == inMenuBar) {		long action;		short menu;		short item;				action = MenuSelect(event->where);		if(action > 0) {			menu = HiWord(action);			item = LoWord(action);			switch(menu) {				case MENU_APPLE:					if(item == MENU_APPLE_ABOUT) {						SysBeep(1);					}					break;									case MENU_CONNECTION:					if(item == MENU_CONNECTION_QUIT) {						cleanup_and_exit();					}					break;									case MENU_CHANNEL:					break;			}			HiliteMenu(0);		}	} else if (clicked_part == inDrag) {		DragWindow(window, event->where, &qd.screenBits.bounds);	} else if (clicked_part == inGoAway) {		if(TrackGoAway(window, event->where)) {			DisposeWindow(window);		}	} else if (clicked_part == inContent) {		if (window != FrontWindow()) {			SelectWindow(window);		}	}}void ask_for_deets(ConnectionInfo *ci){	DialogPtr dlg;	DialogItemIndex hit;	DialogItemType type;	Handle host_edit;	Handle port_edit;	Handle nick_edit;	Rect box;		dlg = GetNewDialog(DLOG_CONN_INFO, NULL, (WindowPtr) -1);		GetDialogItem(dlg, DLOG_CONN_INFO_HOST, &type, &host_edit, &box);	GetDialogItem(dlg, DLOG_CONN_INFO_PORT, &type, &port_edit, &box);	GetDialogItem(dlg, DLOG_CONN_INFO_NICK, &type, &nick_edit, &box);	ShowWindow(dlg);	ModalDialog(NULL, &hit);	if(hit == DLOG_CONN_INFO_CONNECT) {		Str255 host, port, nick;		char *c_host, *c_port, *c_nick;				GetDialogItemText(host_edit, host);		GetDialogItemText(port_edit, port);		GetDialogItemText(nick_edit, nick);				c_host = P2CStr(host);		c_port = P2CStr(port);		c_nick = P2CStr(nick);				strncpy(ci->host, c_host, HOST_MAX);		ci->host[HOST_MAX - 1] = '\0';		strncpy(ci->nick, c_nick, NICK_MAX);		ci->nick[NICK_MAX - 1] = '\0';				ci->port = atoi(c_port);				DisposeDialog(dlg);	} else {		cleanup_and_exit();	}}int main(void){	EventRecord event;	ConnectionInfo connection;	const char *str;		str = "NICK test123___\r\nUSER test * * :test client\r\n";		toolbox_init();	menu_init();	tcp_init();	dns_init(NULL);		ask_for_deets(&connection);		window_init();		gStream = connect(connection.host, connection.port);	send_userinfo(gStream, "test123___", "hello", "test client");		log("server: %s", connection.host);	log("port: %d", connection.port);	log("nick: %s", connection.nick);		while(1) {		WindowPtr clicked_window;		WindowPartCode clicked_part;				Boolean got_event;		got_event = WaitNextEvent(everyEvent, &event, LONG_MAX, NULL);		if(got_event) {			switch(event.what) {				case mouseDown:					clicked_part = FindWindow(event.where, &clicked_window);					handle_mouse_down(&event, clicked_window, clicked_part);					break;				case updateEvt:					BeginUpdate((WindowPtr) event.message);					EndUpdate((WindowPtr) event.message);					break;				case nullEvent:					spoll(gStream, process_line);					break;							}		} else {			spoll(gStream, process_line);		}	}		return 0;}